{"version":3,"file":"gen/index.html","sources":["src/game.c","src/physics.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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","sourcesContent":["#include <stdlib.h>\n#include <time.h>\n#include <math.h>\n\n#include \"game.h\"\n#include \"physics.h\"\n\n// Global variables\nbool quit = false;\nSDL_Event event;\nunsigned int tick = 0;\n\n// Surfaces\nSDL_Surface *screen = NULL;\n\nint main(int argc, char** argv) {\n    SDL_Init(SDL_INIT_VIDEO);\n    screen = SDL_SetVideoMode(SCREEN_WIDTH, SCREEN_HEIGHT,\n            SCREEN_BPP, SDL_SWSURFACE);\n\n#ifdef TEST_SDL_LOCK_OPTS\n    EM_ASM(\"SDL.defaults.copyOnLock = false; SDL.defaults.discardOnLock = true; SDL.defaults.opaqueFrontBuffer = false;\");\n#endif\n\n    srand(time(NULL));\n\n    for (int i=0; i<100; i++) {\n        // get random x, y, vx, vy\n        add_projectile(\n            rand() % SCREEN_WIDTH,\n            rand() % SCREEN_HEIGHT,\n            rand() % 20 - 10,\n            rand() % 20 - 10,\n            rand() % 50 + 5);\n    }\n\n    // Add a big one\n    add_projectile(SCREEN_WIDTH/2, SCREEN_HEIGHT/2, 0, 0, 100);\n\n    /*\n    add_projectile(SCREEN_WIDTH/2, SCREEN_HEIGHT/2 - 20, 0, 0, 20);\n    add_projectile(SCREEN_WIDTH, SCREEN_HEIGHT/2 + 20, -2, 0, 20);\n    */\n\n    emscripten_set_main_loop(game_tick, 0, 1);\n\n    return 0;\n}\n\nvoid game_tick() {\n\n    tick++;\n\n    physics_tick();\n\n    //While there's an event to handle\n    while( SDL_PollEvent( &event ) )\n    {\n        //If a key was pressed\n        if( event.type == SDL_KEYDOWN )\n        {\n        }\n\n    }\n\n    //if (SDL_MUSTLOCK(screen)) SDL_LockSurface(screen);\n\n    //\n    // Draw background\n    //\n    SDL_FillRect(screen, NULL, SDL_MapRGBA(screen->format, 0, 0, 0, 255));\n\n    //\n    // Draw projectiles\n    //\n    \n    for (int i=0; i<get_num_projectiles(); i++) {\n        struct projectile *p = get_projectile(i);\n\n        //printf(\"rect: %d, %d, %d, %d\\n\", rect.x, rect.y, rect.w, rect.h);\n        int d = (int) sqrt(p->diam);\n        int x = p->x - d/2;\n        int y = p->y - d/2;\n\n        SDL_Rect rect = {x, y, d, d};\n\n        int r, g, b;\n        r = 255; \n        g = (int)(255.0 * p->mass / 60.0);\n        b = 0;\n\n        SDL_FillRect(screen, &rect, SDL_MapRGBA(screen->format, r, g, b, 255));\n    }\n\n    //if (SDL_MUSTLOCK(screen)) SDL_UnlockSurface(screen);\n\n    SDL_Flip(screen); \n}\n\nvoid apply_surface( int x, int y, SDL_Surface* source, SDL_Surface* destination, SDL_Rect* clip)\n{\n    //Holds offsets\n    SDL_Rect offset;\n\n    //Get offsets\n    offset.x = x;\n    offset.y = y;\n\n    //Blit\n    SDL_BlitSurface( source, clip, destination, &offset );\n}\n","#include <math.h>\n\n#include \"game.h\"\n#include \"physics.h\"\n\n#define MAX_PROJECTILES 2000\n\nstatic struct projectile projectile[MAX_PROJECTILES];\nstatic int num_projectiles = 0;\n\nstruct projectile* get_projectile(int i) {\n    return &projectile[i];\n}\nint get_num_projectiles() {\n    return num_projectiles;\n}\n\nvoid add_projectile(double x, double y, double vx, double vy, double mass) {\n    if (num_projectiles >= MAX_PROJECTILES) {\n        printf(\"Too many projectiles!\\n\");\n        return;\n    }\n\n    struct projectile *p = get_projectile(num_projectiles);\n\n    p->x = x;\n    p->y = y;\n    p->vx = vx;\n    p->vy = vy;\n    p->mass = mass;\n    p->diam = (int)mass/5;\n\n    num_projectiles++;\n}\n\nvoid physics_tick() {\n    for (int i=0; i<num_projectiles; i++) {\n        struct projectile *p = get_projectile(i);\n\n        p->lastX = p->x;\n        p->lastY = p->y;\n\n        p->x += p->vx;\n        p->y += p->vy;\n\n\n        //\n        // Bounce projectiles off of boundaries\n        //\n        if (p->x < 0) {\n            p->x = 0;\n            p->vx *= -1 * FRICTION;\n        }\n        if (p->x >= SCREEN_WIDTH) {\n            p->x = SCREEN_WIDTH-1;\n            p->vx *= -1 * FRICTION;\n        }\n        if (p->y < 0) {\n            p->y = 0;\n            p->vy *= -1 * FRICTION;\n        }\n        if (p->y >= SCREEN_HEIGHT) {\n            p->y = SCREEN_HEIGHT-1;\n            p->vy *= -1 * FRICTION;\n        }\n\n\n        //\n        // Compute new vx and vy\n        //\n        for (int j=0; j<num_projectiles; j++) {\n            if (i == j) continue;\n\n            struct projectile *q = get_projectile(j);\n\n            double rSqrd = pow(q->x - p->x, 2) + pow(q->y - p->y, 2);\n            double r = sqrt(rSqrd);\n\n            if (r < 3) {\n                continue;\n            }\n\n            double theta = atan2(q->y - p->y, q->x - p->x);\n\n            // F = G m1 m2 / r^2\n            double force = GRAV_CONST * p->mass * q->mass / rSqrd;\n            double fx = force * cos(theta);\n            double fy = force * sin(theta);\n\n\n            // F = ma\n            // a = F/m\n            double ax = fx / p->mass;\n            double ay = fy / p->mass;\n\n            p->vx += ax;\n            p->vy += ay;\n        }\n\n    }\n}\n"]}